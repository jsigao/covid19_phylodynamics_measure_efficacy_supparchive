# this script reads in a sequence alignment (assumed to be downloaded from GISAID)
# and then filters them to generate an alignment to use in the inference
library(ape)
library(seqinr)

#####################
# read in alignment #
#####################
submission_dateby <- "092220"
collection_dateby <- "030820"
reference_genome_name_string <- "EPI_ISL_402125"
nuc_unambig <- c("a", "c", "g", "t")
aa_unambig <- c("A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "W", "Y")

# read in the alignment (aligned from the sequences generated by preprocessing)
# for applying this script, modify the path here
alignment <- read.dna(paste0("./data/gisaid_directly/", submission_dateby, "_aligned.fasta"),
                      format = "fasta", as.character = T)
if (is.list(alignment)) {
  sequence_name <- names(alignment)
} else {
  sequence_name <- rownames(alignment)
}
sequence_accession <- as.character(sapply(sequence_name, function(x) unlist(strsplit(x, "\\|"))[2]))


#####################
# read in meta data #
#####################
# for applying this script, modify the path here
metadata <- read.table(paste0("./data/gisaid_directly/metadata_", submission_dateby, ".tsv"), header = T, sep = "\t", 
                       quote = "\"", stringsAsFactors = F, check.names = F, comment.char = "")
colnames(metadata)[colnames(metadata) == "gisaid_epi_isl"] <- "accession_id"
colnames(metadata)[colnames(metadata) == "date"] <- "collection_date"
metadata <- metadata[metadata$accession_id %in% sequence_accession, ]
collection_date <- as.Date(metadata$collection_date, format = "%Y-%m-%d", tz = "UTC")

nometainfo_exclude <- sequence_name[!(sequence_accession %in% metadata$accession_id)]
if (is.list(alignment)) {
  alignment <- alignment[!sequence_name %in% nometainfo_exclude]
  sequence_name <- names(alignment)
} else {
  alignment <- alignment[!sequence_name %in% nometainfo_exclude, ]
  sequence_name <- rownames(alignment)
}
gc()
gc()

sequence_accession <- as.character(sapply(sequence_name, function(x) unlist(strsplit(x, "\\|"))[2]))
sequence_date <- as.Date(sapply(sequence_name, function(x) unlist(strsplit(x, "\\|"))[3]), format = "%Y-%m-%d", tz = "UTC")

dateinname_id <- which((!is.na(sequence_date[match(metadata$accession_id, sequence_accession)])) & is.na(collection_date))
if (length(dateinname_id) > 0) {
  collection_date[dateinname_id] <- sequence_date[match(metadata$accession_id, sequence_accession)][dateinname_id]
}

# exclude sequences that were sampled after the specified collection date or those without sampling time info
nospecificdate_ordatetoorecent_exclude <- sequence_name[match(metadata$accession_id[is.na(collection_date) | 
                                                                                         collection_date > as.Date(collection_dateby, format = "%m%d%y", tz = "UTC")], 
                                                                 sequence_accession)]

# make sure that the alignment is a matrix
# when it's not, it's due to a small number of sequences with different length, so we exclude them
if (is.list(alignment)) {
  alignment <- alignment[!sequence_name %in% nospecificdate_ordatetoorecent_exclude]
  gc()
  nsites_all <- lengths(alignment)
  nsites_all_tab <- table(nsites_all)
  alignment <- alignment[nsites_all == as.integer(names(nsites_all_tab)[nsites_all_tab == max(nsites_all_tab)])]
  sequence_name <- names(alignment)
  alignment <- matrix(unlist(alignment), nrow = length(alignment), byrow = T)
  rownames(alignment) <- sequence_name
} else {
  alignment <- alignment[!rownames(alignment) %in% nospecificdate_ordatetoorecent_exclude, ]
  sequence_name <- rownames(alignment)
}
sequence_accession <- as.character(sapply(sequence_name, function(x) unlist(strsplit(x, "\\|"))[2]))


##############################
# first round of fliteration #
##############################
# exclude sequences that were not geographically categorized to the desired level (adm1 for US, China, and Canada)
metainfo_toovague_exclude <- sequence_name[match(metadata$accession_id[metadata$division %in% c("USA", "China", "Canada")], sequence_accession)]

# exclude nonhuman sequences
nonhuman_exclude <- grep("/pangolin/|/bat/|/tiger/|/cat/|/canine/|IVDC-HB-env|/env/", sequence_name, value = T)

# duplicate sequences
# for applying this script, modify the path here
duplicate_exclude_string <- scan("./data/meta_data/exclude_seqs.txt", what = character(), sep = "\n", comment.char = "#")
duplicate_exclude <- unlist(sapply(duplicate_exclude_string, function(x) grep(x, sequence_name, value = T)))

# sequence with too much missing and/or too short
sequence_nomissing_length <- apply(alignment, 1, function(x) sum(x %in% nuc_unambig))
toomuchmissing_andor_tooshort_exclude <- sequence_name[sequence_nomissing_length < 29000]

sequence_name_exclude <- unique(c(nonhuman_exclude, metainfo_toovague_exclude, toomuchmissing_andor_tooshort_exclude, duplicate_exclude))
alignment <- alignment[!(sequence_name %in% sequence_name_exclude), ]
gc()
gc()


###############################
# second round of fliteration #
###############################
sequence_name <- rownames(alignment)
sequence_accession <- as.character(sapply(sequence_name, function(x) unlist(strsplit(x, "\\|"))[2]))

# for applying this script, modify the path here
metadata <- read.table(paste0("./data/gisaid_directly/metadata_", submission_dateby, ".tsv"), header = T, sep = "\t", 
                       quote = "\"", stringsAsFactors = F, check.names = F, comment.char = "")
colnames(metadata)[colnames(metadata) == "gisaid_epi_isl"] <- "accession_id"
colnames(metadata)[colnames(metadata) == "date"] <- "collection_date"

metadata <- metadata[metadata$accession_id %in% sequence_accession, ]
metadata <- metadata[match(sequence_accession, metadata$accession_id), ]
collection_date <- as.Date(metadata$collection_date, format = "%Y-%m-%d", tz = "UTC")

#####################################
# information from reference genome #
#####################################
# get the reference genome
reference_inalignment <- alignment[grep(reference_genome_name_string, rownames(alignment)), ]
reference_genome <- reference_inalignment[reference_inalignment %in% nuc_unambig]

# reference genome annotation
gene_names <- c("5primeUTR", "nsp1", "nsp2", "nsp3", "nsp4_TM", "nsp5ab_3CLpro", "nsp6_TM", "nsp7", "nsp8", "nsp9_binding", "nsp10", 
                "nsp11", "nsp12_rdrp", "nsp13_helicase", "nsp14_exonuclease", "nsp15_endoRNAse", "nsp16_OMT", "S", "orf3a", "E", "M", 
                "orf6", "orf7a", "orf7b", "orf8", "N", "orf10", "3primeUTR")
reference_genome_annotation <- matrix(c(1, 265, 266, 805, 806, 2719, 2720, 8554, 8555, 10054, 10055, 10972, 10973,
                                        11842, 11843, 12091, 12092, 12685, 12686, 13024, 13025, 13441, 
                                        13442, 13468, 13468, 16236, 16237, 18039, 18040, 19620, 19621, 20658, 20659, 21552, 
                                        21563, 25384, 25393, 26220, 26245, 26472, 26523, 27191, 27202, 27387, 
                                        27394, 27759, 27756, 27887, 27894, 28259, 28274, 29533, 29558, 29674, 29675, 29903), 
                                      ncol = 2, byrow = T)
rownames(reference_genome_annotation) <- gene_names

# trim the 5primeUTR and 3primeUTR
reference_genome_53primeUTRtrimmed <- reference_genome[reference_genome_annotation[2, 1]:reference_genome_annotation[nrow(reference_genome_annotation) - 1, 2]]
reference_genome_53primeUTRtrimmed_length <- length(reference_genome_53primeUTRtrimmed)

reference_genome_53primeUTRtrimmed_startstring <- paste(reference_genome_53primeUTRtrimmed[1:15], collapse = "")
reference_genome_53primeUTRtrimmed_endstring <- paste(reference_genome_53primeUTRtrimmed[(reference_genome_53primeUTRtrimmed_length - 14):reference_genome_53primeUTRtrimmed_length], collapse = "")

# get the coding region starting and ending positions
reference_inalignment_string <- paste(reference_inalignment, collapse = "")
reference_inalignment_53primeUTRtrimmed_stringsplit <- unlist(strsplit(reference_inalignment_string, 
                                                                       paste(c(reference_genome_53primeUTRtrimmed_startstring, 
                                                                               reference_genome_53primeUTRtrimmed_endstring), collapse = "|")))

alignment_coding_startpos <- length(unlist(strsplit(reference_inalignment_53primeUTRtrimmed_stringsplit[1], ""))) + 1
alignment_coding_endpos <- ncol(alignment) - length(unlist(strsplit(reference_inalignment_53primeUTRtrimmed_stringsplit[3], "")))

# trim the two ends of the alignment that have too much missing
aligment_missingprop_persite <- apply(alignment, 2, function(x) 1 - (sum(x %in% nuc_unambig)/nrow(alignment)))
totrim_front_endpos <- max(which(aligment_missingprop_persite >= 0.1)[which(aligment_missingprop_persite >= 0.1) < alignment_coding_startpos])
totrim_end_startpos <- min(which(aligment_missingprop_persite >= 0.1)[which(aligment_missingprop_persite >= 0.1) > alignment_coding_endpos])
alignment <- alignment[, -c(1:totrim_front_endpos, totrim_end_startpos:ncol(alignment))]

# remove the sites within the coding region that have majority missing (extremely likely due to miss-alignment/sequencing error induced insertion)
aligment_missingprop_persite <- apply(alignment, 2, function(x) 1 - (sum(x %in% nuc_unambig)/nrow(alignment)))
alignment <- alignment[, -which(aligment_missingprop_persite >= 0.5)]

# repeat the previous step again to get the coding region after the above quality control steps
reference_inalignment <- alignment[grep(reference_genome_name_string, rownames(alignment)), ]
reference_inalignment_string <- paste(reference_inalignment, collapse = "")
reference_inalignment_53primeUTRtrimmed_stringsplit <- unlist(strsplit(reference_inalignment_string, 
                                                                       paste(c(reference_genome_53primeUTRtrimmed_startstring, 
                                                                               reference_genome_53primeUTRtrimmed_endstring), collapse = "|")))
alignment_coding_startpos <- length(unlist(strsplit(reference_inalignment_53primeUTRtrimmed_stringsplit[1], ""))) + 1
alignment_coding_endpos <- ncol(alignment) - length(unlist(strsplit(reference_inalignment_53primeUTRtrimmed_stringsplit[3], "")))

alignment_53primeUTRtrimmed <- alignment[, alignment_coding_startpos:alignment_coding_endpos]
reference_inalignment_53primeUTRtrimmed <- alignment_53primeUTRtrimmed[grep(reference_genome_name_string, 
                                                                            rownames(alignment_53primeUTRtrimmed)), ]
if (length(reference_inalignment_53primeUTRtrimmed) != 29409) {
  stop("something wrong")
}

# compute the number of sites that are nonambiguous and different from reference genome
numsites_diff_toref <- integer(nrow(alignment_53primeUTRtrimmed))
for (i in 1:nrow(alignment_53primeUTRtrimmed)) {
  
  alignment_53primeUTRtrimmed_current <- alignment_53primeUTRtrimmed[i, ]
  alignment_53primeUTRtrimmed_current[!(alignment_53primeUTRtrimmed_current %in% nuc_unambig)] <- reference_inalignment_53primeUTRtrimmed[!(alignment_53primeUTRtrimmed_current %in% nuc_unambig)]
  numsites_diff_toref[i] <- sum(sapply(1:ncol(alignment_53primeUTRtrimmed), 
                                       function(j) alignment_53primeUTRtrimmed_current[j] != reference_inalignment_53primeUTRtrimmed[j]))
}

days_sincefirst <- as.integer(collection_date - min(collection_date)) + 51
# exclude the sequences with too many different sites 
# setting to 1/3 now as of 04/06/2020; may need to increase a couple months later
toodiff_toref_exclude <- rownames(alignment_53primeUTRtrimmed)[(numsites_diff_toref/days_sincefirst) >= 1/3]

# exclude the sequences with too many missing/ambiguous sites
alignment_53primeUTRtrimmed_missing_num <- apply(alignment_53primeUTRtrimmed, 1, function(x) length(x) - sum(x %in% nuc_unambig))
toomuch_missing_exclude <- rownames(alignment_53primeUTRtrimmed)[alignment_53primeUTRtrimmed_missing_num >= 21 | 
                                                                   (alignment_53primeUTRtrimmed_missing_num >= 12 & 
                                                                      numsites_diff_toref <= alignment_53primeUTRtrimmed_missing_num)]

alignment <- alignment[!(rownames(alignment_53primeUTRtrimmed) %in% unique(c(toodiff_toref_exclude, toomuch_missing_exclude))), ]
days_sincefirst <- days_sincefirst[!(rownames(alignment_53primeUTRtrimmed) %in% unique(c(toodiff_toref_exclude, toomuch_missing_exclude)))]


######################################################################
# check each sequence to see if there is any stop codons             #
# any sequence with stop codon within each gene needs to be excluded #
######################################################################
# trim the alignment to get the regions that are all coding (i.e., removing intergenic chunks)
alignment_annotation <- reference_genome_annotation + alignment_coding_startpos - reference_genome_annotation[2, 1]
alignment_annotation_coding <- alignment_annotation[!rownames(alignment_annotation) %in% c("5primeUTR", "3primeUTR"),]

alignment_codingonly <- apply(alignment_annotation_coding, 1, function(x) alignment[, x[1]:x[2]])
alignment_codingonly <- do.call(cbind, alignment_codingonly)

# sanity check to make sure in the reference genome, stop codons only appear at where they should be exactly
reference_inalignment_aa <- translate(alignment_codingonly[grep(reference_genome_name_string, rownames(alignment_codingonly)), ], ambiguous = T)
stopcodon_aapos <- c(8370, 8646, 8722, 8945, 9007, 9129, 9173, 9295, 9715, 9754)
if (!all.equal(which(reference_inalignment_aa == "*"), stopcodon_aapos)) {
  stop("something wrong")
}
reference_inalignment_aa_string <- paste(reference_inalignment_aa[-stopcodon_aapos], collapse = "")

# sanity check to make sure the reference genome aa sequence translated here is identical to the genbank sequence
reference_aa_path <- list.files("./data/sequence_data/reference_genome", full.names = T)
reference_aa <- lapply(reference_aa_path, function(x) seqinr::read.fasta(x, seqtype = "AA"))
protein_name <- c("orf1ab", "S", "orf3a", "E", "M", "orf6", "orf7a", "orf7b", "orf8", "N", "orf10")

reference_aa <- reference_aa[match(protein_name, gsub("aa_|.fasta", "", basename(reference_aa_path)))]
reference_aa_string <- paste(unlist(reference_aa), collapse = "")
if (reference_inalignment_aa_string != reference_aa_string) {
  stop("something wrong")
}

# remove stop codons from the coding only alignment
stopcodon_nucpos <- integer(length(stopcodon_aapos) * 3)
for (i in 1:length(stopcodon_aapos)) {
  stopcodon_nucpos[(i - 1) * 3 + 1:3] <- (stopcodon_aapos[i] - 1) * 3 + 1:3
}
alignment_codingonly <- alignment_codingonly[, -stopcodon_nucpos]
if (ncol(alignment_codingonly) != 9744 * 3) {
  stop("something wrong")
}

# generate the amino acid alignments so that we can check for stop codons
alignment_aa <- matrix(NA, ncol = 9744, nrow = nrow(alignment_codingonly), byrow = T)
for (i in 1:nrow(alignment_codingonly)) {
  alignment_aa[i, ] <- translate(gsub("\\-|\\?", "n", alignment_codingonly[i, ]), ambiguous = T)
}
rownames(alignment_aa) <- rownames(alignment_codingonly)

# exclude the sequences with any stop codons in the coding regions
alignment_stopcodon_num <- apply(alignment_aa, 1, function(x) sum(x == "*"))
stopcodon_exclude <- names(alignment_stopcodon_num)[alignment_stopcodon_num != 0]

# exclude the sequences with too many different sites
# setting to 2/15 now as of 04/06/2020; may need to increase a couple months later
reference_inalignment_aa <- alignment_aa[grep(reference_genome_name_string, rownames(alignment_aa)), ]
numsites_diff_toref <- integer(nrow(alignment_aa))
for (i in 1:nrow(alignment_aa)) {
  alignment_aa_current <- alignment_aa[i, ]
  alignment_aa_current[!(alignment_aa_current %in% aa_unambig)] <- reference_inalignment_aa[!(alignment_aa_current %in% aa_unambig)]
  numsites_diff_toref[i] <- sum(sapply(1:ncol(alignment_aa), function(j) alignment_aa_current[j] != reference_inalignment_aa[j]))
}
toodiff_toref_exclude <- rownames(alignment_aa)[numsites_diff_toref/days_sincefirst > 2/15]

# exclude the sequences with too many missing/ambiguous sites
# setting to 6 and 3 (median of numsites_diff_toref) now as of 03/28/2020; may need to increase a couple months later
alignment_aa_missing_num <- apply(alignment_aa, 1, function(x) sum(x == "X"))
toomuch_missing_exclude <- names(alignment_aa_missing_num)[alignment_aa_missing_num >= 6 | 
                                                             (alignment_aa_missing_num > 3 & 
                                                                numsites_diff_toref < alignment_aa_missing_num)]

# generate the final alignments after the above quality control steps
alignment <- alignment[!(rownames(alignment) %in% unique(c(stopcodon_exclude, toodiff_toref_exclude, toomuch_missing_exclude))), ]

# exclude sequences that were sampled from the same individual
duplicate_exclude <- character()
virus_name <- gsub("hCoV-19/", "", sapply(strsplit(rownames(alignment), "\\|"), "[[", 1))
if (any(duplicated(virus_name))) {
  virus_name_dup <- unique(virus_name[duplicated(virus_name)])
  
  for (i in 1:length(virus_name_dup)) {
    sequence_name_dup <- rownames(alignment)[virus_name == virus_name_dup[i]]
    submission_date_dup <- as.Date(metadata$date_submitted[metadata$strain == virus_name_dup[i]], format = "%Y-%m-%d", tz = "UTC")
    duplicate_include <- sequence_name_dup[submission_date_dup == max(submission_date_dup)]
    if (length(duplicate_include) > 1) {
      accession_id_num <- as.integer(gsub("EPI_ISL_", "", sapply(strsplit(duplicate_include, "\\|"), "[[", 2)))
      duplicate_include <- duplicate_include[accession_id_num == max(accession_id_num)]
    }
    
    duplicate_exclude <- c(duplicate_exclude, sequence_name_dup[sequence_name_dup != duplicate_include])
  }
  
  alignment <- alignment[!(rownames(alignment) %in% duplicate_exclude), ]
}

##############################################################
# translate into AA and codon alignment, then write out them #
##############################################################
alignment_aa <- alignment_aa[rownames(alignment_aa) %in% rownames(alignment), ]
alignment_codon <- alignment_codingonly[rownames(alignment_codingonly) %in% rownames(alignment), ]

# for applying this script, modify the path here
write.dna(alignment, file = paste0("./data/gisaid_directly/", submission_dateby, "_", collection_dateby, "_aligned_trimmed.fasta"), 
          format = "fasta", nbcol = -1, colsep = "", colw = 3.2e4)
seqinr::write.fasta(sequences = lapply(1:nrow(alignment_aa), function(i) alignment_aa[i, ]), names = rownames(alignment_aa), 
                    file.out = paste0("./data/gisaid_directly/", submission_dateby, "_", collection_dateby, "_aligned_aa.fasta"))
write.dna(alignment_codon, file = paste0("./data/gisaid_directly/", submission_dateby, "_", collection_dateby, "_aligned_codon.fasta"), 
          format = "fasta", nbcol = -1, colsep = "", colw = 3.2e4)
